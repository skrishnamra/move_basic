
bool MoveBasic::approachLinear(tf2::Transform& goalInDriving,
                           const std::string& drivingFrame)
{
    tf2::Transform poseDriving;
    if (!getTransform(drivingFrame, baseFrame, poseDriving)) {
         abortGoal("MoveBasic: Cannot determine robot pose for linear approach");
         return false;
    }
    tf2::Transform goalInBase = poseDriving * goalInDriving;
    tf2::Vector3 remaining = goalInBase.getOrigin();

    remaining.setZ(0);
    double requestedDistance = remaining.length();

    bool pausingForObstacle = false;
    ros::Time obstacleTime;
    ros::Duration runawayTimeout(runawayTimeoutSecs);
    ros::Time last = ros::Time::now();

    // For lateral control
    double lateralIntegral = 0.0;
    double lateralError = 0.0;
    double prevLateralError = 0.0;
    double lateralDiff = 0.0;
    double sign;
    double signX;
    double signY;



    bool done = false;
    ros::Rate r(50);

    while (!done && ros::ok()) {
        ros::spinOnce();
        r.sleep();

        if (!getTransform(drivingFrame, baseFrame, poseDriving)) {
             ROS_WARN("MoveBasic: Cannot determine robot pose for linear approach");
             return false;
        }
        goalInBase = poseDriving * goalInDriving;
        remaining = goalInBase.getOrigin();
        double distRemaining = sqrt(remaining.x() * remaining.x() + remaining.y() * remaining.y());
        // Change according to axis 
        distRemainingX = abs(remaining.x());
        if(remaining.x() < 0.0){
            signX = -1;
        }
        else{
            signX = 1;
        }

        distRemainingY = abs(remaining.y());
        if(remaining.y() < 0.0){
            signY = -1;
        }
        else{
            signY = 1;
        }

        double obstacleDist = 99999;


        ROS_INFO("%f", distRemainingX);
        double velocityX = std::max(minLinearVelocity,
		std::min(std::min(std::abs(obstacleDist), std::abs(distRemainingX/2)),
                	std::min(maxLinearVelocity, std::sqrt(2.0 * linearAcceleration *
								    std::min(std::abs(obstacleDist), std::abs(distRemainingX))))));

        ROS_INFO("%f", distRemainingY);
        double velocityY = std::max(minLinearVelocity,
		std::min(std::min(std::abs(obstacleDist), std::abs(distRemainingY/2)),
                	std::min(maxLinearVelocity, std::sqrt(2.0 * linearAcceleration *
								    std::min(std::abs(obstacleDist), std::abs(distRemainingY))))));
        // ROS_INFO("Vel:%f", velocity);

        bool obstacleDetected = (obstacleDist < forwardObstacleThreshold);
        // Disable obstacle avoidance
        obstacleDetected = false;
        if (obstacleDetected) {
            velocity = 0;
            if (!pausingForObstacle) {
                ROS_INFO("MoveBasic: PAUSING for OBSTACLE");
                obstacleTime = ros::Time::now();
                pausingForObstacle = true;
            }
            else {
                ROS_INFO("MoveBasic: Still waiting for obstacle at %f meters!", obstacleDist);
                ros::Duration waitTime = ros::Time::now() - obstacleTime;
                if (waitTime.toSec() > obstacleWaitThreshold) {
                    abortGoal("MoveBasic: Aborting due to obstacle");
                    return false;
                }
            }
        }

        if (!obstacleDetected && pausingForObstacle) {
            ROS_INFO("MoveBasic: Resuming after obstacle has gone");
            pausingForObstacle = false;
        }

        // Abort Checks
        if (actionServer->isPreemptRequested()) {
            ROS_INFO("MoveBasic: Stopping move due to preempt");
            actionServer->setPreempted();
            sendCmd(0, 0, 0);
            return false;
        }

        /* Finish Check */

        if (distRemaining < linearTolerance) {
            ROS_INFO("MoveBasic: Done linear, error: x: %f meters, y: %f meters", remaining.x(), remaining.y());
            velocity = 0;
            done = true;
            sendCmd(rotation, velocity);
            return done;
        }
        sendCmd(rotation, velocityX * signX, velocityY * signY);
        ROS_DEBUG("Distance remaining: %f, Linear velocity: %f", distRemaining, velocity);
    }

    return done;
}